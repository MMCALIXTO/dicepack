<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      const NOTATION_REGEXP = /^((-?)(\d+|\d*d\d+))([+-](\d+|\d*d\d+))*$/;
      const DICE_REGEXP = /^-?(\d+|\d*d\d+)$/;
      const STARTING_D_WIHTOUT_COUNT = /^(-?)d/;

      const validate = function(string, regexp) {
        if (typeof string !== 'string' || !regexp.test(string)) {
          throw new Error(`Given expression ${string} isn't valid`);
        }
        return string;
      };

      const castToNumber = function(string) {
        const number = parseInt(string);
        return typeof number === 'undefined' || isNaN(number) ? 1 : number;
      };

      const getDice = function(expression) {
        const [_count, _side] = validate(expression, DICE_REGEXP)
          // restore dropped 1d with sign 1d
          .replace(STARTING_D_WIHTOUT_COUNT, '$11d')
          .split('d')
          .map(castToNumber);
        const side = castToNumber(_side);
        const count = _count === -0 ? 0 : _count;
        return { count, side };
      };

      const parse = expression =>
        validate(expression, NOTATION_REGEXP)
          .replace(/-/g, '+-')
          .split('+')
          .filter(string => string !== '')
          .map(getDice);

      const myDice = parse('8d6');

      const independentProbabilities = myDice.reduce(function(accumulator, current) {
        const { count, side } = current;
        const _count = Math.abs(count);
        const sign = _count / count;
        if (side === 1) {
          accumulator.push([count]);
        } else {
          let dieProbabilities = [];
          for (let result = 1; result <= side; result++) {
            dieProbabilities.push(sign * result);
          }
          for (let die = 0; die < _count; die++) {
            accumulator.push(dieProbabilities);
          }
        }
        return accumulator;
      }, []);

      console.log(independentProbabilities);

      const sum = (accumulator, current) => accumulator + current;

      const directProduct = (accumulator, current) => [].concat(...current.map(x => accumulator.map(y => sum(x, y))));

      const linkedProbabilities = independentProbabilities.reduce(directProduct, [0]);

      console.log(linkedProbabilities);

      const linkedProbabilitiesCount = linkedProbabilities.length

      const ojidanie = linkedProbabilities.reduce(sum, 0) / linkedProbabilitiesCount;
      console.log(ojidanie);

      const dispersion = linkedProbabilities.map(result => Math.pow((result - ojidanie),2)).reduce(sum) / linkedProbabilitiesCount;
      console.log(dispersion);

      const square = Math.sqrt(dispersion);
      console.log(square);

      const chanceTable = linkedProbabilities.map(result => {
        const chance = 1/linkedProbabilities.length;
        return { chance, result };
      });

      const compactProbabilities = chanceTable.reduce((accumulator, current) => {
        let key = String(current.result);
        if (!accumulator[key]) {
          accumulator[key] = current;
        } else {
          accumulator[key].chance = accumulator[key].chance + current.chance;
        }
        return accumulator;
      }, {});

      const distribution = Object.values(compactProbabilities).sort((a, b) => (a.result - b.result));

      console.log(distribution);

      const test = distribution.reduce((accumulator, current) => accumulator + current.chance, 0);
      console.log(test);
    </script>
  </body>
</html>
